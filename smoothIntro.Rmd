---
title: "Smoothing Intro"
author: "Michael M Thomas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

## Packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse) # general data cleanup
library(magrittr) # pipe for function nesting
library(here) # for working directory help

library(sp) # spatial data plotting and classes
library(rgdal) # working with coordinate reference systems
library(rgeos) # topology operations on geometric objects
library(spdep) # adjacency matrix generation

```

## Read in the .shp file
The .shp file is read in by *rgdal::readOGR*. The *here::here* function is used to make sure if this file is knitted from somewhere other than the project root, then the data can still be properly referenced.

```{r dataReadin}
# Create SpatialPolygonsDataFrame
gaCounty <- readOGR(here("Data"), 
                    "County",
                    verbose = F)

# Set ID attribute of polygons to their "natural" names instead of numbers

# Georgia Counties Named
gaCounty_n <- spChFIDs(
  obj = gaCounty,
  x = as.character(gaCounty$NAME))

# Read in the aggregated data
popData <- readxl::read_xlsx("Data/PopData.xlsx") %>% 
  mutate(MortRate = Mortality / Population * 1000) %>% 
  arrange(match(County, as.character(gaCounty$NAME))) %>% 
  data.frame()

row.names(popData) <- as.character(gaCounty$NAME)

```


# Create the *nb* object
Here the SpatialPolygonsDataFrame is used to determine county adjacency. Luckily, Georgia doesn't have any islands that are counties or weird boarders caused by holes in the map. The *spdep* package uses boundary proximity to determine neighbor status. Interestingly, indicating queen adjacency (only one shared point between counties required for adjacency) does make a difference in this case. Emanuel county has a few neighbors that only touch it at a point. In this case, queen adjacency is set to *F*, because those small boarders don't seem to indicate similarity the way a large boarder might.

```{r createNb, fig.align='center'}
# Create spatial neighbors
gaCounty_nb <- poly2nb(gaCounty_n, queen=F) # Queen contingency MATTERS see emanuel county

emanuelBbox <- SpatialPolygons(gaCounty_n@polygons[match("Emanuel", as.character(gaCounty$NAME))])@bbox

plot(gaCounty_n, xlim = emanuelBbox["x",], ylim = emanuelBbox["y",], main = "Plot of Emanuel County")

# plot(gaCounty_n[match("Emanuel", as.character(gaCounty$NAME))], 
#      add = T, 
#      border = "red")

```

# Class investigation
For some reason, the *nb* objects are S3 and the *Spatial\*DataFrame* objects are S4. Understanding how to access the attributes of both will improve the ease with which these objects are accessed/manipulated.

```{r classInvestigation}

# Shows that this is just a list written in S4
pryr::otype(gaCounty_nb)
str(gaCounty_nb[1:5])
summary(gaCounty_nb)

# Annoyingly, nb objects are S3 whereas sp objects are S4
pryr::otype(gaCounty_n)
getClass(class(gaCounty_n))

# Shows the attributes of the object
# attributes(gaCounty_nb)
```


# Adjacency Smoothing

```{r smoothingAlgo}

num <- popData$Mortality
denom <- popData$Population

# Creates an empty numeric vector to hold the values of the smoothing
aggData <- data.frame(MortRateSmooth = numeric(length(gaCounty_nb)))

# Add row names to the data frame for later merging
row.names(aggData) <- row.names(gaCounty_n)

# Combine the aggregate data with the original population data
gaCountyData <- cbind(popData,aggData)

# Cycle through rows of neighbors taking proportion of cases in queen
# neighbors
for(i in 1:length(gaCounty_nb)) {
  
  indeces <- c(i,gaCounty_nb[[i]])
  
  # gaCountyData$MortRateSmooth[i] <- sum(num[indeces]) / sum(denom[indeces]) * 1000
  gaCountyData$MortRateSmooth[i] <- mean(num[indeces] / denom[indeces]) * 1000

  }

# confirmation, Catoosa County
# (14 / 68939 + # Dade
# 24 /  66550 + # Walker
# 16 / 104658  # Whitfield
# ) / 3


# Add the data with tht new vector to gaCounty
gaCounty_df <- SpatialPolygonsDataFrame(gaCounty_n, gaCountyData)

gaCounty_df$MortRate <- ifelse(gaCounty_df$MortRate == 0, NA_real_, gaCounty_df$MortRate)

```


# Raw data and smoothed data plot
The raw mortality rates are plotted below. To emphasize the difficulty of working with potentially small numerators, the counties with 0 oversdose deaths are plotted with no coloring.

```{r mortRate, fig.align='center'}

p <- spplot(gaCounty_df, zcol = c("MortRate"), main = "Smoothed Mortality Rates 17")
p
# summary(gaCounty_df@data$MortRate)

```

```{r mortRateSmooth, fig.align='center'}

ps <- spplot(gaCounty_df, zcol = c("MortRateSmooth"), main = "Adjacency Smoothed Mortality Rates 17")
ps

# summary(gaCounty_df@data$MortRateSmooth)

gaCounty_df@data %>% 
  gather(Type, Val, MortRate, MortRateSmooth) %>% 
  mutate(County = fct_reorder(County, Val)) %>% 
  replace_na(list(Val = 0)) %>% 
  ggplot(aes(x = County, y = Val, fill = Type)) +
  geom_bar(stat = "identity") +
  theme(legend.position = "None") +
  facet_grid(rows  = ~Type) +
  scale_x_discrete(labels = NULL) 

```

# Try a different weighting algorithm
The weights $w_i$ are the inverse distance between the centroid and its neighbor. I set the value of the distance between region $i$ itself to be the non-zero minimum.
```{r smoothDistWeight}

gaCountyData$MortRateSmoothDist <- numeric(length = length(gaCounty_nb))

# Find distance between two polygons

dist_matrix <- as.matrix(dist(gCentroid(gaCounty_df, byid = T)@coords))

nonZero_min <- function(x) min(subset(x, x !=0))

for(i in 1:length(gaCounty_nb)) {
  
  indeces <- c(i,gaCounty_nb[[i]])
  
  w_i <- dist_matrix[indeces, i]
  w_i[1] <- nonZero_min(w_i)
  
  gaCountyData$MortRateSmoothDist[i] <- sum((1 / w_i) * (num[indeces] / denom[indeces]) * 1000) /
    sum((1 / w_i)) # * 
    # 1000 # Removed times 1000 because we are no longer in incidence measures

  }


# Add the data with tht new vector to gaCounty
gaCounty_df <- SpatialPolygonsDataFrame(gaCounty_n, gaCountyData)

gaCounty_df$MortRate <- ifelse(gaCounty_df$MortRate == 0, NA_real_, gaCounty_df$MortRate)


```

```{r mortRateDist, fig.align='center'}

ps <- spplot(gaCounty_df, zcol = c("MortRateSmoothDist"), main = "Inv Dist Smoothed Mortality Rates 17")
ps
# summary(gaCounty_df@data$MortRateSmooth)

gaCounty_df@data %>% 
  gather(Type, Val, MortRate, MortRateSmooth, MortRateSmoothDist) %>% 
  mutate(County = fct_reorder(County, Val)) %>% 
  replace_na(list(Val = 0)) %>% 
  ggplot(aes(x = County, y = Val, fill = Type)) +
  geom_bar(stat = "identity") +
  theme(legend.position = "None") +
  facet_grid(rows  = ~Type, scales = "free_y") +
  scale_x_discrete(labels = NULL) 

```
  