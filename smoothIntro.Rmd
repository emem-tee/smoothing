---
title: "Smoothing Intro"
author: "Michael M Thomas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

## Packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse) # general data cleanup
library(magrittr) # pipe for function nesting
library(here) # for working directory help

library(sp) # spatial data plotting and classes
library(rgdal) # working with coordinate reference systems
library(rgeos) # topology operations on geometric objects
library(spdep) # adjacency matrix generation


```

## Read in the .shp file
The .shp file is read in by *rgdal::readOGR*. The *here::here* function is used to make sure if this file is knitted from somewhere other than the project root, then the data can still be properly referenced.

```{r dataReadin}
# Create SpatialPolygonsDataFrame
gaCounty <- readOGR(here("Data"), 
                    "County",
                    verbose = F)

# Set ID attribute of polygons to their "natural" names instead of numbers

# Georgia Counties Named
gaCounty_n <- spChFIDs(
  obj = gaCounty,
  x = as.character(gaCounty$NAME))

# Read in the aggregated data
popData <- readxl::read_xlsx("Data/PopData.xlsx") %>% 
  mutate(MortRate = Mortality / Population * 1000) %>% 
  arrange(match(County, as.character(gaCounty$NAME))) %>% 
  data.frame()

row.names(popData) <- as.character(gaCounty$NAME)

```


# Create the *nb* object
Here the SpatialPolygonsDataFrame is used to determine county adjacency. Luckily, Georgia doesn't have any islands that are counties or weird boarders caused by holes in the map. The *spdep* package uses boundary proximity to determine neighbor status. Interestingly, indicating queen adjacency (only one shared point between counties required for adjacency) does make a difference in this case. Emanuel county has a few neighbors that only touch it at a point. In this case, queen adjacency is set to *F*, because those small boarders don't seem to indicate similarity the way a large boarder might.

```{r createNb}
# Create spatial neighbors
gaCounty_nb <- poly2nb(gaCounty_n, queen=F) # Queen contingency MATTERS see emanuel county

emanuelBbox <- SpatialPolygons(gaCounty_n@polygons[match("Emanuel", as.character(gaCounty$NAME))])@bbox

plot(gaCounty_n, xlim = emanuelBbox["x",], ylim = emanuelBbox["y",], main = "Plot of Emanuel County")

# plot(gaCounty_n[match("Emanuel", as.character(gaCounty$NAME))], 
#      add = T, 
#      border = "red")

```


```{r classInvestigation}

# Shows that this is just a list written in S4
pryr::otype(gaCounty_nb)
str(gaCounty_nb[1:5])
summary(gaCounty_nb)

# Annoyingly, nb objects are S3 whereas sp objects are S4
pryr::otype(gaCounty_n)
getClass(class(gaCounty_n))

# Shows the attributes of the object
# attributes(gaCounty_nb)
```


```{r smoothingAlgo}

num <- popData$Mortality
denom <- popData$Population

# Creates an empty numeric vector to hold the values of the smoothing
aggData <- data.frame(MortRateSmooth = numeric(length(gaCounty_nb)))

# Add row names to the data frame for later merging
row.names(aggData) <- row.names(gaCounty)

# Combine the aggregate data with the original population data
gaCountyData <- cbind(popData,aggData)

# Cycle through rows of neighbors taking proportion of cases in queen
# neighbors
for(i in 1:length(gaCounty_nb)) {
  
  indeces <- c(i,gaCounty_nb[[i]])
  
  # gaCountyData$MortRateSmooth[i] <- sum(num[indeces]) / sum(denom[indeces]) * 1000
  gaCountyData$MortRateSmooth[i] <- mean(num[indeces] / denom[indeces]) * 1000

  }


# Add the data with tht new vector to gaCounty
gaCounty_df <- SpatialPolygonsDataFrame(gaCounty, gaCountyData)

gaCounty_df$MortRate <- ifelse(gaCounty_df$MortRate == 0, NA_real_, gaCounty_df$MortRate)

```


# Assign the "smooth" vector back to the original dataset


```{r mortRate}

p <- spplot(gaCounty_df, zcol = c("MortRate"), main = "Smoothed Mortality Rates 17")
p
summary(gaCounty_df@data$MortRate)

```

```{r mortRateSmooth}

ps <- spplot(gaCounty_df, zcol = c("MortRateSmooth"), main = "Smoothed Mortality Rates 17")
ps
summary(gaCounty_df@data$MortRateSmooth)

```

# Try a different weighting algorithm

```{r smoothDistWeight}

gaCountyData$MortRateSmoothDist <- numeric(length = length(gaCounty_nb))

# Find distance between two polygons

dist_matrix <- as.matrix(dist(gCentroid(gaCounty_df, byid = T)@coords))

for(i in 1:length(gaCounty_nb)) {
  
  indeces <- c(i,gaCounty_nb[[i]])
  
  gaCountyData$MortRateSmoothDist[i] <- sum(dist_matrix[indeces, i] * (num[indeces] / denom[indeces])) /
    sum(dist_matrix[indeces, i]) # * 
    # 1000 # Removed times 1000 because we are no longer in incidence measures

  }


# Add the data with tht new vector to gaCounty
gaCounty_df <- SpatialPolygonsDataFrame(gaCounty, gaCountyData)

gaCounty_df$MortRate <- ifelse(gaCounty_df$MortRate == 0, NA_real_, gaCounty_df$MortRate)


```

```{r mortRateDist}

ps <- spplot(gaCounty_df, zcol = c("MortRateSmoothDist"), main = "Smoothed Mortality Rates 17")
ps
summary(gaCounty_df@data$MortRateSmooth)

```
  